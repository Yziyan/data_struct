# 红黑树前言 —— 篇一

## 写在前面

### 文章摘要

1. 初识红黑树
2. 红黑树的五条性质
3. 红黑树的平衡
4. 红黑树 vs B树
5. 红黑树 vs AVL树


### 阅读准备

* 建议阅读时间：5 ~ 10 分钟
* 本文提到的二叉搜索树、AVL树、B树，推荐阅读：
    * [《二叉搜索树的实现与分析》](https://juejin.cn/post/7168286143430000671 "https://juejin.cn/post/7168286143430000671")
    * [《透过AVL树的实现，学习树的旋转》](https://juejin.cn/post/7172467470928707591)
    * [《你心里有B树吗？》](https://juejin.cn/post/7174639541272199226)
* 学习了AVL树，心里也有了点B树。今天我们来简单认识下红黑树吧~



## 一、初识

* 在了解红黑树之前，先来看一棵红黑树大概长什么样子

![image-20221108213645970](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1baf3f88960b4adb8d87a1e6fb6c09a0~tplv-k3u1fbpfcp-zoom-1.image)

* 有没有感觉**很好看、很工整、很平衡、很有规律、很疑惑、很....** ？
* 没关系，不妨听我细细说来，咱们都能学会~
* 同AVL树一样，红黑树也是一种自平衡的二叉搜索树。一开始被称为：`对称二叉B树`
* 我们在AVL树中，通过树的旋转，维护了AVL树中特有的平衡因子，使其平衡。
* 里面旋转的思想，在红黑树里也是需要使用的。这一点应该能想到。
* 可为什么和B树也有关呢？难道红黑树它心里也有B树？

![image-20221110101019826](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7169f2dc23dd4ddd801439b1d8e395d9~tplv-k3u1fbpfcp-zoom-1.image)



* 乍眼一看，红黑树好像确实很有**4阶B树**的样子哎
* 那我们下面将一起来看看，我们之前学习的 [AVL树](https://juejin.cn/post/7172467470928707591)、[B树](https://juejin.cn/post/7174639541272199226)，会与红黑树擦出什么样的火花
* 但是在了解红黑树前，我们先来背背八股文



## 二、红黑树的性质

**① 节点是红色或黑色**

* 红黑树是每个节点都带有颜色属性的二叉搜索树，颜色为红色或黑色
* 红色和黑色代表什么呢？来看看维基百科的解释：

> 之所以选择“红色”是因为这是作者在[帕罗奥多研究中心公司](https://zh.wikipedia.org/w/index.php?title=帕羅奧多研究中心公司&action=edit&redlink=1)（[Xerox PARC](https://zh.wikipedia.org/wiki/帕羅奧多研究中心)）工作时用彩色激光打印机可以产生的最好看的颜色。另一种说法来自Guibas，是因为红色和黑色的笔是他们当时可用来绘制树的颜色。

* 其实没有特殊含义，可能是因为时代的原因吧。也可能为了方便描述以下性质吧~

**② 根节点是黑色**

* 根节点必须是黑色，这一点很好理解

**③ 叶子节点都是黑色**

* 这里所说的叶子节点，和我们之前所说的叶子节点不太一样。红黑树中的叶子节点是：**是外部的节点、是空的节点、是假想出来的节点**

![image-20221108220650745](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9761458ded41118255a1e8fd6436c6~tplv-k3u1fbpfcp-zoom-1.image)

**④ 红色节点的子节点都是黑色**

* 换好几句话说就是：
    * 每个红色节点必须有两个黑色的子节点`（叶子节点也算入其中）`
    * 或者说从每个叶子到根的所有路径上不能有两个连续的红色节点
    * 或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系
    * 或者说红色节点的父节点和子节点均是黑色的



**⑤ 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点**

![image-20221108221527557](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d217c9b78a450a8081ba7444199452~tplv-k3u1fbpfcp-zoom-1.image)

* 如图中所示，有三条颜色的路线，都是从同一个节点出发（这里是根节点）
* 它们从不同路线，走到了不同的叶子节点
* 但是它们所经历的黑色节点都是一样的：3个
* 其它路线也是同理，不信你可以自己数一数~



### 总结

* 要是一棵`二叉搜索树`拥有这五条性质，那么它就是一棵`红黑树`，也就拥有了**自平衡**的功能
* 而且这五条性质是**缺一不可的**，要想是红黑树，就必须满足上述性质
* ❓可是拥有了这五条性质，真的能够使二叉搜索树自平衡吗？别着急，听我细细道来~


## 三、红黑树与B树

* 说完了红黑树的 5 条性质。为了能够更好的学习红黑树，我们先来看看它与B树之间的关系

![image-20221109144719638](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/986da1c60cb24e39b4f3e23977f5a23c~tplv-k3u1fbpfcp-zoom-1.image)

* 从图中可以看出，我们将`红色节点`向上与`黑色父节点`合并后
* 红黑树与`四阶B树。也叫做（2，4）树、2-3-4树`具有**等价性**
* **将黑色节点与它的红色子节点融合在一起**，会形成1个B树节点
* 并且红黑树的黑色节点个数等于4阶B树的节点总数`（黑节点数量 = 4阶B树节点数量）`
* 既然要用红色节点与黑色节点合并，那么合并后，就只有这四种情况：
    * 红黑红、黑红、红黑、黑
    * **建议可以眼熟一下，因为这里对后面红黑树添加、删除分析的理解尤为重要**

![image-20221109150438138](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ca7ad41ae643479be8d690fef07a9d~tplv-k3u1fbpfcp-zoom-1.image)

* 既然等价于`四阶B树`，那我们一起来回想一下4阶B树的两个性质：
    * **根节点**：`(2 ≤ 子节点个数 ≤ 4)、(1 ≤ 元素个数 ≤ 3)`
    * **非根节点**：`(2 ≤ 子节点个数 ≤ 4)、(1 ≤ 元素个数 ≤ 3)`


## 四、红黑树的平衡

* 看到这里，你可能还是会有这个疑惑：❓拥有这五条性质的二叉搜索树，就能保证它是平衡的吗？
* 看完了红黑树与B树的**等价变换**，我们至少能保证：**红黑树等价于4阶B树**
* 再来看看这一棵红黑树的等价变换：

![image-20221119095219840](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85c8d7b987c426381f453d65a037e6d~tplv-k3u1fbpfcp-zoom-1.image)

* 红黑树的高度为4，和它等价的B树高度为2，将眼光放在这棵4阶B树上，肉眼可见它的平衡
* 其实红黑树的平衡，在某种意义上来说，就是4阶B树的平衡。4阶B树有多么平衡，红黑树就有多么平衡。
* 我们刚才所说，红黑树的黑色节点数量等于B树的节点数量，也就说明**红黑树的平衡是一种黑高度平衡**
* 根据性质，也就可以知道，红黑树的平衡比较宽松：**没有一条路径高度会大于其他路径高度的2倍**

![image-20221119100034477](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6be2fa18f484726bd4125a529541298~tplv-k3u1fbpfcp-zoom-1.image)

* 也就说明红黑树的平衡是一种弱平衡

> 红黑树的最大高度是 `2log2(n + 1)`，因此根的高度也是`O(logn)`

* 根据高度，也就可以得出红黑树的平均时间复杂度：
    * 搜索、添加、删除：`O(logn)`

## 五、红黑树与AVL树

* 有了二叉搜索树，防止它退化成链表，出现了自平衡的二叉搜索树：`AVL树`
* 而我们都知道，`AVL树`的平衡标准比较严格：**每个左右子树的高度差不超过1**。据统计：
    * 同样100w个节点，AVL树最大高度为28，而红黑树最大高度为40
* 刚刚分析红黑树的时间复杂度，我们发现，其实和AVL树的是一样的，查询、添加、删除都是`O(logn)`级别
* 那科学家之后为什么又发明了红黑树？并且实际应用也更广泛呢？
* 引用*清华邓俊辉老师的话：*

> 每次插入、删除操作，虽然最坏时间复杂度是O(logn) 但是，旋转操作只会进行常数次。也就是说只有常数个节点的拓扑结构发生改变，**这个特性对持久性数据结构是至关重要的。**

* 回顾一下`AVL树的实现中`：
    * 添加后可能会导致一个或多个节点失衡，在解决最小的失衡节点后，就平衡了。最多需要2次旋转即可解决失衡，只需要`O(1)`级别的旋转操作
    * 删除后可能只会有一个节点失衡，但是在解决失衡后，还可能会出现失衡节点。也就是可能需要多次调用旋转逻辑，最多需要`O(logn)`级别的旋转操作
* 而在红黑树中，先说结论，之后的实现中再说明：
    * 添加和删除后，都仅需要`O(1)`级别的旋转操作即可维护红黑树的性质
* 对于查询操作来说，因为红黑树的平衡不是很严格，相同数量的节点，大部分情况下，树的高度都比AVL树要高，所以，查询的速度AVL树会快一些。

* “一图胜千言”（来自网络）

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4ba4e7bddb547908c4e8793a382d122~tplv-k3u1fbpfcp-zoom-1.image)

* 其实综合看下来：
    * 查询的次数远远大于插入和删除的次数时，选用AVL树
    * 查询、添加、删除次数几乎差不多，选择红黑树
    * 相对于AVL树来说，红黑树牺牲了部分平衡，减少了插入、删除操作中旋转的次数
    
# 如何在红黑树上添加节点？ —— 篇二

## 一、红黑树的实现前的铺垫

> “工欲善其事，必先利其器”

* 为了更好的学习红黑树，我们已经学习了：`AVL树、B树`
* 下面，再铺垫几个方法，辅助我们学习红黑树


### （1）几个名词

* 父节点：`parent`（一直所说的父节点）
* 兄弟节点：`sibling`（父亲相同的节点）
* 叔父节点：`uncle`（父节点的兄弟节点）
* 祖父节点：`grandparent`（父节点的父节点）
* 在二叉搜索树的内部，我们本来就维护了父节点，不用处理，祖父节点也是同理
* 为了方便起见，我们在二叉搜索树的`Node`节点中，可以添加获取兄弟节点的方法`sibling()`。有了此方法，叔父节点也就可以通过`parent.sibling()`拿到了

![image-20221109160057127](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1702fe5786834015bca636bfc5bf3a6c~tplv-k3u1fbpfcp-zoom-1.image)

* 看完了这几个名词，我们来看看红黑树的基本构造

### （2）红黑树的基本构造

* 较为简单，先看代码

```java
public class RBTree<E> extends BSTImpl<E> {

    private static final boolean RED = false; // 红色
    private static final boolean BLACK = true; // 黑色

    public RBTree() { this(null); }

    /**
     * 可以传入一个比较器的构造函数
     * @param comparator：比较器
     */
    public RBTree(Comparator<E> comparator) {
        super(comparator);
    }
    
    @Override
    protected void afterAdd(Node<E> node) {
        // 添加节点后的逻辑
    }

    @Override
    protected void afterRemove(Node<E> node) {
        // 删除节点后的逻辑
    }
    
    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new RBNode<>(element, parent); // 需要使用红黑树的节点
    }
}
```

* 红黑树和`AVL树`一样，都是在二叉搜索树的基础上，添加了自平衡的功能
* 那么，都需要继承自二叉搜索树`BST`
* 回想一下，`AVL树`是通过维护平衡因子，使其失衡后恢复平衡
* 那红黑树呢？其实上面谈性质的时候已经说了：**通过维护节点的颜色（红、黑），使其失衡后恢复平衡**
* 所以我们内部定义了两个常量：`RED、BLACK`，用于方便标识节点的颜色。因为只有两种颜色，使用`boolean`类型即可
* 还有：`afterAdd()、afterRemove()`两个方法，相信不用我多说了吧。如果不清楚，强烈推荐看看上篇文章[《AVL树的实现》](https://juejin.cn/post/7172467470928707591)
* 基本构造了解后，来看看红黑树内部的节点对象。外部使用的是元素，可内部操作的是节点。这一点应该很清楚了


### （3）红黑树内部的节点

* 二叉搜索树的节点，就维护了父亲、兄弟节点、存储的元素
* 而`AVL树`在此基础上，添加了节点高度的属性
* 那红黑树的节点应该长什么样呢？

```java
    private static class RBNode<E> extends Node<E> {
        /**
         * 节点的颜色【默认为红色】
         */
        boolean color = RED;
        public RBNode(E element, Node<E> parent) {
            super(element, parent);
        }
    }
```

* 在二叉搜索树节点的基础上，额外维护一个颜色即可
* 并且让它的颜色**默认为红色，因为能够更快的满足红黑树的性质**


### （4）一些辅助函数

#### ① 节点上色

* 既然牵扯到了颜色，之后肯定需要调整节点的颜色
* 方便之后使用，我们提供给节点上色的方法

```java
    /**
     * 将节点上色
     * @param node：待染色节点
     * @param color：待染的颜色
     * @return ：被染色的节点
     */
    private Node<E> color(Node<E> node, boolean color) {
        if (node == null) return node;
        ((RBNode<E>)node).color = color; // 染色
        return node;
    }

    /**
     * 将节点染成红色
     */
    private Node<E> red(Node<E> node) {
        return color(node, RED);
    }

    /**
     * 将节点染成黑色
     */
    private Node<E> black(Node<E> node) {
        return color(node, BLACK);
    }
```

#### ② 查看节点颜色
* 因为要遵循红黑树的5条性质，之后肯定要经常获取节点的颜色信息
* 方便之后使用，我们提供获取节点颜色的方法


```java
    /**
     * 查看节点颜色
     * @param node：节点
     * @return ：节点的颜色
     */
    private boolean colorOf(Node<E> node) {
        return node == null ? BLACK : ((RBNode<E>) node).color;
    }

    /**
     * 查看是否是红色的节点
     */
    private boolean isRed(Node<E> node) {
        return colorOf(node) == RED;
    }

    /**
     * 查看是否是黑色的节点
     */
    private boolean isBlack(Node<E> node) {
        return colorOf(node) == BLACK;
    }
```


## 二、添加

### （1）分析

* 如下，有一棵红黑树，先不管如何在它上面添加节点，先来做一个约定：
* **在讨论红黑树时，心中应该立刻想到它等价的B树**

![image-20221109195059502](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fe0f01262794002af7b1f296b14a92d~tplv-k3u1fbpfcp-zoom-1.image)

* 先看看右边等价的B树，回想B树的性质：**如果在B树中添加元素，新元素必然是添加到叶子节点中**
* 所以，添加的节点只能位于最下层的节点：（4、8、10）（16、18）（22、25）（36）
* 而对应红黑树节点的颜色，对应B树的叶子节点就只有这四种情况：`红黑红、黑红、红黑、黑`
* 又因为有一些节点已经有叉了，所以最终节点能添加的位置只有这些了：

![image-20221109201014803](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10e4826a82e84fd48020b505cb0e13b9~tplv-k3u1fbpfcp-zoom-1.image)

* 也就是上图所示的：`新1 ~ 新12，12种情况`。其实...... 也不多是吧......
* 又因为想要红黑树尽快的成长起来，**添加的节点默认是红色**
* 我们一直在说：**添加的节点默认是红色，能够尽快的满足红黑树的5条性质**。为什么呢？
* 回看性质：

![image-20221109202206337](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3991f5a0537f49009cd685bd32bd9b80~tplv-k3u1fbpfcp-zoom-1.image)

* ①：肯定是**毋庸置疑**的
* ②：因为B树新添加的节点肯定在叶子节点中，在红黑树中，这点也**毋庸置疑**
* ③：红黑树的叶子节点本身就是假想的`null节点`，本身就是黑色，这点**没有问题**
* ⑤：如果添加的节点是红色，从任一节点到新添加的节点，其经过的黑色节点个数肯定不会改变（有没有加入黑色节点），这一点也**没有问题**
* ④：乍眼一看，**新节点如果是红色，①、②、③、⑤ 这几条性质都能满足**。而第 ④ 条性质呢？
    * 如果**添加的节点的父节点本身就是红色了，再添加一个红色的节点，肯定不会满足性质 ④**
    * 则需要额外的操作，来使其重新满足性质 ④
* 经过这简单的分析，你应该知道，我们为什么要将新添加的节点默认为红色了吧


### （2）分类讨论
* 添加的情况太多了，我们来分组讨论一下这 12 种情况：
    * 我们知道了为什么要默认节点为红色，**那么我们也就可以根据添加后是否满足性质④，来分组了**

#### ① 父节点是黑色 —— 没有影响

![image-20221109203935269](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76833a214d7047e19f849fbe7711c565~tplv-k3u1fbpfcp-zoom-1.image)

* 因为父节点是黑色，添加了一个新的红色节点。能够满足红黑树的性质④
* 并且也满足4阶B树的性质，也就是说**不会产生上溢现象**
* 还满足将红黑树转换成4阶B树的情形（将红色子节点与父节点合并成一个超级节点）
* 因此：**父节点是黑色的情况，不需要做任何处理**



#### ② 父节点是红色 —— 需要特殊处理

![image-20221109204412105](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f85319e9f5c479eb163cbe094019b61~tplv-k3u1fbpfcp-zoom-1.image)

* 这八种情况，肉眼可见，首先就不满足红黑树的性质④了
* 也太多了，简直...... 还能不能再细分情况呢？
* 确实很多，那我们回想下`4阶B树`的性质：**`1 ≤ 任一节点的元素个数 ≤ 3 `**
* 剩下的8种情况中，我们发现，添加新节点时，有些会超过3个节点（**会出现上溢现象**），有的不会出现上溢现象
* 那我们就可以**根据添加后，在其等价的`4阶B树`中，节点是否会上溢。来分类讨论**


##### 1、未上溢 —— 通过旋转解决

![image-20221109211646537](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2e91ab2d9d45cbbb4196692b50725a~tplv-k3u1fbpfcp-zoom-1.image)

* 这几种情况，将添加后的新节点合并上去变成`4阶B树`的节点，也不会产生上溢现象。只需要通过 **染色 + 旋转** 即可解决
* 说到旋转，我们可不陌生了，如果还陌生的话，再次强烈推荐看看：[《透过AVL树的实现，学习树的旋转》](https://juejin.cn/post/7172467470928707591)
* 若需要旋转，新添加的节点会出现`LL、RR、LR、RL`，这四种情况
* 与之前`AVL树`的讨论一样，**我们先来看看单旋即可解决的两种情况**：`LL、RR`

![image-20221109213643037](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4211ea7832b44f08f542b2d6b909592~tplv-k3u1fbpfcp-zoom-1.image)

* 先不谈如何旋转，我们先站在将红黑树等价转换成B树的角度，来看问题
* 如果需要将新添加的节点向上合并到父节点所在层，那么**父节点肯定得是黑色**，被向上合并的**子节点都得是红色**
* 如果这一点明白了，那么就明白，为什么要先染色了`（当然，先染色是因为还未旋转、节点的关系还没发生变化、更容易找到需要染色的节点）`
* 来看看思路：
    * 1、将父节点染成【黑色】，祖父节点染成【红色】
    * 2、将祖父节点进行单旋操作【LL就右旋、RR就左旋】
    * 3、将父节点变成祖父节点的子节点


* 至于对旋转的分析，可以看看`AVL树`的文章，这里就不多赘述了，直接看图

![image-20221109215454485](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f8ffa4a7d974d4db73d09e970582f52~tplv-k3u1fbpfcp-zoom-1.image)

* **我们再来看看需要双旋才能解决的两种情况**：`RL、LR`

![image-20221110083107261](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42eb00cde158450bb53e6972b035d408~tplv-k3u1fbpfcp-zoom-1.image)

* 与单旋的操作类似，**染色 + 旋转**，看看思路：
    * 1、将自己染成【黑色】，祖父节点染成【红色】
    * 2、进行双旋【LR：（先父节点左旋、后祖父节点右旋）RL：（先父节点右旋、后祖父节点左旋）】
    * 3、将自己变成祖父节点的子节点


* 直接看图

![image-20221110084227999](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43bdbd951eaa4206928b95583305e071~tplv-k3u1fbpfcp-zoom-1.image)

* 虽然我没有把旋转的过程拆开，但还是希望你能够想一想，将其染色后，旋转的过程
* 如果你了解了上面的四种情况。那恭喜你：在红黑树中添加新节点，有八种情况，你已经理解其思想了，我们来看看最后的四种



##### 2、上溢 —— 通过合并解决

![image-20221110091257180](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e61f9c3cd4314e2e8813dd0cbc934102~tplv-k3u1fbpfcp-zoom-1.image)

* 如图所示，这四个节点，添加任何一个，都超过了4阶B树节点所能容纳元素的最大值，也就是添加后，会变成上溢节点
* 在B树中，若节点出现了上溢的现象，我们是通过向上合并来解决的
* 那在红黑树中呢？其实也差不多，不信你跟着我的思路思考一下

![image-20221110091350803](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f2ebaa723234f90aa081beb84c9ded8~tplv-k3u1fbpfcp-zoom-1.image)

* 如上图，我们添加了节点`新1`后，站在B树的角度来看
* 出现了上溢节点：`（新1、4、8、10）`，需要解决上溢【**找出中间的元素，向上与父节点合并，再将剩下的元素拆分成左右子节点**】
* 于是找到了元素：`4 和 8`，其实将谁向上合并都可以
* 为了方便，我们选择了元素`8`，为什么呢？
* 因为这是红黑树，元素`8`所在的红黑树节点的左右两边，本身就是拆分开的节点，而且找它也很容易

* 那我们直接向上合并，看看还会出现什么问题

![image-20221110093701177](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105b892af67a4f67a64ccb4be7796711~tplv-k3u1fbpfcp-zoom-1.image)

* **①可能会对B树的父节点产生副作用**。如图`（8、13、20、30）`，是再次导致上溢就再次出现了上溢节点
* **②分裂的子节点，作为红黑树等价转换的B树节点，父节点必须是黑色**。如图B树节点`(新1、4)`和`（10）`，是通过红黑树等价转换的，也即。4 和 10 必须是黑色节点
* 如果解决了这两个问题，那这四种情况，也就能顺利的添加上了

* 我们先解决第②个问题：子节点不是黑色
* 如果我们**先将祖父节点染红、父节点和叔父节点染黑，再向上合并祖父节点**呢？

![image-20221110095358826](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8a3a8f225e44078a2c694d2123655c7~tplv-k3u1fbpfcp-zoom-1.image)

* 我们发现，只需要解决对B树而言，产生的副作用就行了。这里出现了新的上溢节点：`（8、13、20、30）`
* 你会发现，我们在染色的时候，不仅将：`父节点、叔父节点`染成了【黑色】，也将`祖父节点`染成了【红色】，为什么呢？
* 现在新节点的`祖父节点8`，是红色
* 而在红黑树中新添加一个节点的颜色，默认也是红色
* 那我们能否将`祖父节点`，看待成是一个新添加的节点呢？
* 如图所示，将 8 添加到节点：`（13、20、30）`中
* 刚刚讨论的，红黑树中，`8的父节点13`是红色（添加到父节点也是红色的情况）。所以需要特殊处理
* 又因为出现了上溢现象。需要**染色 + 合并**。即：

![image-20221110102300156](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a655e9def8c144b599702d86163f25f4~tplv-k3u1fbpfcp-zoom-1.image)

* 也是将祖父节点染成红色、父节点和叔父节点染成黑色后，再向上合并祖父节点
* 经过这样处理过后，可以发现，已经上溢到了根节点。树都长高了
* 这时只需要将根节点`20`，变成黑色节点即可

![image-20221110102454323](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8db08b38a29241929f3321f8edac33cf~tplv-k3u1fbpfcp-zoom-1.image)

* 至此，这一种情况也解决完了。红黑树又恢复了最初的平静

* 向上合并，为什么可能会产生副作用呢？我们是通过什么思路来解决上溢的呢？
* 其实不难想通，我们后面的思路，是将其向上合并的节点，看成是一个新添加的节点。那么新添加的节点。总共有12种情况，有4种没有影响，剩下的8种都需要做额外的操作，才能满足红黑树的5条性质
* 我们一路分类讨论下来，分了三种情况
* 向上合并时，不过是按我们分类的三种情况，再讨论一次罢了，**这个过程其实就是一个递归的过程**
* 至此，添加的思路就已经分析完成了。如果还有些迷，下面我们来总结一下红黑树的添加吧！



### （3）添加的总结

* 总共12种情况，我们利用图示，分了下面三种情况讨论
* 如果用文字描述，就是：**先看父节点，再看叔父节点**

![image-20221110141301732](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b486b248471c4ede9f3b0846cc2944f7~tplv-k3u1fbpfcp-zoom-1.image)

#### ① 父节点是黑色 —— 不需要处理

* 应该可以不用解释了，因为都不需要额外处理嘛
* 除了这四种情况，下面讨论的叔父节点的颜色，都是基于父节点是红色的情况讨论的



#### ② 叔父节点是红色 —— 通过合并解决

* 这种会出现上溢现象，需要：
    * 先染色，再向上合并
    * 最后将向上合并的父节点当做新添加的节点。递归调用添加的逻辑
    * 如果向上合并到了根节点，那么会使对应的B树高度 + 1，这时直接将根节点变成黑色即可



#### ③ 叔父节点不是红色 —— 通过旋转解决

* 1、叔父节点是黑色（递归解决上溢时可能会遇到）
* 2、没有叔父节点的情况，又因为`null节点（叶子节点）`也是黑色
* 这种情况需要：
    * 先染色，再单旋或双旋



### （4）添加的实现

#### 添加前的准备

* 分析与思考结束了，在用代码实现之前，我们先来复习一下，二叉搜索树添加的逻辑：

![image-20221117192129625](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a5187b7c69848a4ad16a8f84a9f1615~tplv-k3u1fbpfcp-zoom-1.image)



#### ① 父节点是黑色 —— 不需要处理

![image-20221110164521788](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0bff6c72a1342c8ab4bf01986a87c68~tplv-k3u1fbpfcp-zoom-1.image)



* 就很单纯，取出父节点，看看父节点的颜色是否为黑色，是的话，不需要做任何处理
* 但是有可能是添加了根节点，根节点必须是黑色，而新添加的节点，默认是红色，所以需要将其染成黑色

![image-20221110135526990](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd8a684677f4c6187a8d0a75096b696~tplv-k3u1fbpfcp-zoom-1.image)



#### ② 叔父节点是红色 —— 通过合并解决

![image-20221110165000882](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6d64bd031c449fa4871d039ed1bd1d~tplv-k3u1fbpfcp-zoom-1.image)



* 看完代码，你可能会有疑惑，不是说要合并解决吗？可是也没看到我去写合并的逻辑啊！
* 是的，其实并不需要去合并，因为我们将其红黑树等价转换成4阶B树，就是方便我们理解
* 而且转换的时候，是将黑色节点与它的红色子节点合并在一起，变成一个B树节点。那我们改变了节点的颜色，它自然就会重新等价转换了
* 你看看这幅图，左边是等价转换的B树，用于方便理解
* 而右边是红黑树，要保持它的性质，真正的操作

![image-20221110143930246](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e6facaa3c94a38b101591634be9f0f~tplv-k3u1fbpfcp-zoom-1.image)



#### ③ 叔父节点不是红色 —— 通过旋转解决

* 这种情况，需要通过旋转来解决。而旋转的逻辑，大部分应该都是和`AVL树`中的逻辑相同的
* 所以在实现这种情况之前，我们先来改造一下继承关系：将中间再加入一层，平衡二叉搜索树

![image-20221110153551512](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee62a6fb53a4038ae79075b0e50df16~tplv-k3u1fbpfcp-zoom-1.image)

* 改变了继承关系之后，我们就能实现代码了

![image-20221110170102676](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106a645a4b624c77953f641540f4eaf0~tplv-k3u1fbpfcp-zoom-1.image)



* 为了写清楚处理逻辑，上面的代码有些重复的地方（待会贴完整代码的时候再精简代码）
* 思路其实很简单，先判断是哪种情况：`LL、LR、RR、RL`
* 根据情形先将对应节点染色、然后再进行旋转【旋转的操作就不多赘述了】



#### ④ 完整实现`afterAdd(Node<E> node)`

```java
protected void afterAdd(Node<E> node) {
    Node<E> parent = node.parent;
    if (parent == null) { // 添加的节点是根节点
        black(node); // 将其染成黑色
        return;
    }

    if (isBlack(parent)) return; // 1、父节点是黑色 —— 不需要处理

    // 写完发现：2、3两种情况，都需要将祖父节点先染成红色，将其抽出来
    Node<E> grandparent = red(parent.parent);
    Node<E> uncle = parent.sibling(); // 取出叔父节点

    if (isRed(uncle)) { // 2、叔父节点是红色 —— 通过合并解决
        // 将父节点、叔父节点染成黑色
        black(parent);
        black(uncle);
        afterAdd(grandparent); // 再将祖父节点当做新添加的节点，去递归调用添加后的逻辑
        return;
    }

    // 来到这里说明：3、叔父节点不是红色 —— 通过旋转解决

    if (parent.isLeftChild()) { // L
        if (node.isLeftChild()) { // LL
            black(parent); // 父节点染成黑色
        } else { // LR
            black(node); // 将自己染成黑色
            // 先左旋、后右旋
            rotateLeft(parent);
        }
        // LL、LR最后都需要将祖父节点右旋
        rotateRight(grandparent);
    } else { // R
        if (node.isRightChild()) { // RR
            black(parent); // 父节点染成黑色
        } else { // RL
            black(node); // 将自己染成黑色
            // 先右旋、后左旋
            rotateRight(parent);
        }
        rotateLeft(grandparent);
    }
}
```

# 红黑树删除的讨论分析 —— 篇三

## 一、如何分析讨论红黑树的删除

### （1）分析

* 分析红黑树时，一定要想象出它等价的4阶B树
* 这是一棵红黑树，将它的**等价B树**给画出来

![image-20221111180500412](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/615c185eef6d46acba18a2d864ff341c~tplv-k3u1fbpfcp-zoom-1.image)

* 看右边的B树，在如果要在上面删除元素，我们知道：**真正被删除的元素都是在叶子节点中的**
* 也就是从图中的这些节点：`（4、8、10）、（16、18）、（22、25）、（36）`中去删除元素
* 加上左边红黑树节点的颜色，对应B树的叶子节点同添加一样，也只有这四种情况：`红黑红、黑红、红黑、黑`

![image-20221111181854679](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0acfcf2ee5f48c19330fa330a57e0b8~tplv-k3u1fbpfcp-zoom-1.image)

* 之前在[《红黑树添加的分析与实现》](https://juejin.cn/post/7177716251215527997)中，我们想要尽快的满足红黑树的五条性质，来使其自平衡
* 我们做了一个操作：**使新添加的节点默认为红色**，经过这个操作后，会发现有几种情况就不需要额外的处理了。
* 在删除节点的时候，有没有不用处理的情况呢？跟着我的思路，我们来分类讨论一下吧~



### （2）分类讨论1

* 在上面的图片中，可以发现，真正会被删除的节点，有黑有红。
* 那下面我们**先按删除节点的颜色分类**，可以分为两类：

#### ① 删除的节点是红色

![image-20221111183904877](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a00a26f45f4079bcee02e4b5676404~tplv-k3u1fbpfcp-zoom-1.image)

* 如图上箭头所指：删除的全部都是**红色节点**
* 我先不解释，我直接将其删掉，你看看图，你就明白了，不信你看看：

![image-20221111184246025](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ca2c8b9e8e471fb7935d2f8ecfc3d0~tplv-k3u1fbpfcp-zoom-1.image)

* 看完上图可以发现：**如果删除的节点是红色的，并不会对红黑树的5条性质产生任何影响**
* 回想之前在添加时，我们也将节点调成了红色再添加，**红色**真的很令人泪目啊！
* 这就是不需要做处理的情况吗？还挺舒服的，还有没有不需要处理的情况呢？
* 别着急，我们慢慢讨论



#### ② 删除的节点是黑色

![image-20221111184842034](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29af63fd95474118815ce87a9cac376a~tplv-k3u1fbpfcp-zoom-1.image)

* 看完了上面的第一种讨论，再来看看这些情况：**删除的节点是黑色的**
* 看起来好像就没刚刚那么舒服了，而且感觉也很笼统
* 那咱们再来细化讨论一下：**按删除节点的`（红色子节点）`的数目**



### （3） 分类讨论2

#### ① 有两个红色的子节点

![image-20221111185700360](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8285cced99d4f4db582ddd1dd93925a~tplv-k3u1fbpfcp-zoom-1.image)

* 在说这种情况之前，我们来简单复习一下`二叉搜索树`中，`删除度为2`的节点时的思路：
    * 找到前驱或后继节点、转换成`度为 0 或 1`的节点进行删除
        * 看上图，我们想要删除节点`8`
        * 在二叉搜索树的眼中，也就是`删除度为2`的节点
        * 需要找到它的前驱或者后继节点`4或10`。先赋值，再删除前驱或后继节点
* 这样一看，发现真正被删除的节点，是`4 或者 10`。看看它们的颜色，这不就是上面讨论的，不需要处理的情况了吗（**真正被删除的是红色节点**）
* 比如我拿前驱节点为例，画一幅图给你看看：

![image-20221111190803872](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff5705282fd44fa991bdd4c9b0539f4~tplv-k3u1fbpfcp-zoom-1.image)

* 可以发现，删除后并没有影响到红黑树的性质，它还是一棵红黑树
* 因为真正被删除的节点是红色，这就等价于上面讨论的第一种情况了~


#### ② 只有一个红色的子节点

![image-20221111192216962](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e7938ed6f74a0fa6392e61a0398152~tplv-k3u1fbpfcp-zoom-1.image)

* 如图箭头所指：想要删除的节点只有一个红色的子节点
* 如果站在B树的角度：
    * 待删除的元素在节点：`（16、18）和 （22、25）`中
    * 在删除后，变成了`（18）和（22）`，还是满足4阶B树的性质，不会产生副作用
* 但是如果站在等价转换的角度来看：
    * 删除后的节点是：`（18）和（22）`，都是红色，不能作为一个B树的节点。
    * 那么需要将它们**染成黑色**，才能独立作为一个B树节点，也就是：

![image-20221111193017381](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d78e53b715cb48278073a4fc632742e2~tplv-k3u1fbpfcp-zoom-1.image)



* 如果站在二叉搜索树的角度：
    * 这是`删除度为1`的节点
    * 需要**找到一个替代它的子节点，让它的父节点指向替代它的子节点**
    * 再维护好红黑树的性质，所以最终思路是：

![image-20221111193642638](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c54b439c316e475ea9c301873d230ed5~tplv-k3u1fbpfcp-zoom-1.image)



#### ③ 没有红色的子节点

* 看到这里，先恭喜你，删除的情况已经讨论了一半。什么？才一半......
* 没关系，耐心一点，毕竟红黑树对大多数人来说，可不简单呢，我们来看看这种情况

![image-20221111195915462](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53b6cd2b6079414086d6678e32ff71c1~tplv-k3u1fbpfcp-zoom-1.image)

* 图中想要删除的元素是`36`，可以发现，它没有红色的子节点
* 探讨这种情况前，我们也来简单复习一下**B树是如何删除元素的**：
    * 首先明确：**真正删除的元素必然在叶子节点中**
    * 在叶子节点中的元素，直接删除即可
    * 但是在删除完成后，需要检验是否满足m阶B树的性质：`┍ m/2 ┑ - 1 ≤ 非根节点元素个数 ≤ m - 1（m为阶数）`
    * 若满足该性质，则删除成功，不需要做额外的处理
    * 若不满足，则会产生下溢现象，需要处理下溢节点
    * 处理完成后可能还会继续下溢，重复解决下溢，直至完全平衡。删除才完成
* 既然提到了下溢，那顺便谈谈如何解决下溢：
    * 先看看，可否与临近的兄弟节点借一个元素
    * 若可以借，则通过旋转的方式，借用元素、下溢解决
    * 若没得借，则需要从父节点中取出一个元素，与兄弟节点（如果有）中的元素合并成一个节点
    * 从父节点中取出一个元素，可能会导致父节点也下溢。那么需要重复上面的过程解决下溢。直至下溢完全解决
* 相信到现在，不用我再解释一遍，我们学红黑树，为什么要来看B树的删除吧！

* 我们想要删除节点：`（36）`节点中的元素 36

![image-20221111203251668](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6f6ca1b023447959e6e133459009ac7~tplv-k3u1fbpfcp-zoom-1.image)

* 因为其等价的是4阶B树，有这样的`1 ≤ 节点元素数量 ≤ 3`关系。
* 从图中可以发现，节点的元素数量为0了，已经超出了这个范围，也就是出现了下溢现象，所以我们下面要解决下溢
* 并且由于这是一棵红黑树，解决下溢时，需要满足红黑树的5条性质，也需要满足它们间等价转换的关系
* 既然要解决下溢，是不是又可以分类讨论了：**按解决下溢的办法分类**



##### 1、临近兄弟节点有得借 —— 兄弟节点是黑色

![image-20221112091803449](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5fd6d2f6f6403ea987a2e86e8ac764~tplv-k3u1fbpfcp-zoom-1.image)

* 我们来看图中的这几种情况:
    * 在B树的眼中：待删除元素所在节点的兄弟节点是：`红黑、红黑红、黑红`，它们至少可以向借一个元素`（它们借出去了，也不会产生影响）`
    * 在红黑树的眼中：**待删除节点的兄弟节点是黑色的，并且至少有一个红色的子节点**
* 如果是上面的这些情况，那么向兄弟节点借一个元素过来即可。怎么借呢？
* 刚复习的，直接**旋转**过来即可，我们先看兄弟节点是`红黑、黑红、`这两种情况：

![image-20221112095406438](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933faa24c0e647228083f814f1bb41a7~tplv-k3u1fbpfcp-zoom-1.image)

* 如图所示，当删除元素后，在B树的角度来看，得先通过旋转来解决下溢：
    * 具体如何旋转，主要是看删除节点的父节点是：`LL、LR、RR、RL`中的哪一种情况，决定如何使用左旋和右旋，这里就不多赘述了
* 然后在红黑树与其等价转换的角度来看，需要维护红黑树的性质，也就是给节点的染色：
    * 将旋转到上方新的父节点颜色**继承原先父节点的颜色**（要满足等价转换的条件：红色节点向上合并）
    * 将**新父节点的左右子节点变成黑色**（要满足等价转换的条件：黑色节点才能独立作为一个B树节点）

* 说完了刚刚：`红黑、黑红`的两种情况，我们再来看看剩下一种可以借元素给兄弟的情况：`红黑红`

![image-20221112102845988](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64f4f145f4fb44a6813301fff8de5e7b~tplv-k3u1fbpfcp-zoom-1.image)

* 为什么要把这种情况单独拿出来说呢？从图中可以看出，不论是在B树还是红黑树的角度。两棵一样的红黑树删除同样的节点，最终结果却不同，为什么呢？
    * 可以发现，在选择旋转策略的时候，用了两种方式：单旋和双旋
    * 而这两种策略，最终的结果虽然不一样，可是都满足了B树的性质
    * 再通过染色。来维护节点的颜色后，结果肯定也不一样，可是也都满足了红黑树的性质
* 所以，得出的结论是：**导致结果不同的是旋转的策略不同**。
* 而结果都皆大欢喜，也就是说，两种其实都没错。选择任意一种都可以
* 看完了上面的三种情况，是不是只有会出现：`LL、LR`的情况啊？`RR、RL`去哪里了啊？

![image-20221112144459641](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a425dc2038a4f039a4a60dd339d1ad8~tplv-k3u1fbpfcp-zoom-1.image)

* 如上图所示，其实也会出现：`RR、RL`，只不过**待删除的节点在父节点的左边**来了而已，【**下面的讨论情况也是一样的**】
* 那这些情况该怎么分析呢？咱们也就不必duck担心，其实不用分析了，只需要掌握好待删除节点在右边的情况即可
* 因为**待删除节点在左边的情况，与在右边的情况，操作是对称的，染色的逻辑是一致的**。
* 这种可以跟兄弟节点借元素的情况，**关于染色**，我再补充一点，小伙伴可能会有的疑惑：
    * 为什么我要说：旋转后新的父节点（中心节点）**必须要继承旧父节点的颜色**呢？
    * 看上面画的图，染色操作不都是将旋转后新父节点，染成红色吗？
    * 别着急，咱们来看看下面这幅图：

![image-20221112151350774](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24178f794d4d46429533c145895c43dc~tplv-k3u1fbpfcp-zoom-1.image)

* 看到上图所示的情形，如果只是简单的将新父节点染成红色的话，就不满足性质了。`（将红黑树的5条性质罚抄一百遍，相信你不敢乱染色了吧！！！)`
* 正确的操作是**继承旧父节点的颜色**



##### 2、临近的兄弟节点没得借 —— 兄弟节点是黑色

* 说完了别人家的兄弟`（可以借）`，来看看自己家的兄弟`（没得借）`的情况，比如说下面的两种情况：

![image-20221112153839462](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c24776548b849808ff8e061bcc855c9~tplv-k3u1fbpfcp-zoom-1.image)

* 不是兄弟节点不想借给你，而是人家里面都只有一个元素了，根本借不出来啊
* 根据B树的性质：我们知道**在兄弟没得借的时候，要在父节点中取出一个元素，与兄弟节点合并**
* 说到合并，之前添加后若出现上溢现象，也要通过合并来解决，我们来看看，它们有什么相似的地方吗？

![image-20221112155604810](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed618cd1223448e84952da9e90fcf1f~tplv-k3u1fbpfcp-zoom-1.image)

* 上图中上部是方便我们理解，等价转换出来的B树，下部分是这棵红黑树，这种情况下真正执行的操作
* 与添加一样：**真正的操作其实是去染色**，并没有真的去合并
    * 父节点染成`【黑色】`兄弟节点染成`【红色】`

* 染完色，我们按照红黑树等价转换成B树的性质，再次转换成帮助我们理解的B树时
* 会发现，B树的性质也得到了满足
* 之前分析添加时**解决上溢，向上合并后，可能会导致上面的父节点也上溢**
* **解决下溢也是同理，向下合并后，可能会导致父节点也下溢**

![image-20221112181847201](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e43712e9528643b0ad03cbc2b14d778e~tplv-k3u1fbpfcp-zoom-1.image)

* 的确如此，**向下合并后，可能导致父节点也下溢。而且最坏的情况，会一直下溢到根节点**（如上图）
* 回想之前添加时，放上去与父节点合并的元素，我们会**把它当做一个新添加的元素，重复进行行添加时的分析逻辑**，也就是会去递归调用添加后的处理函数
* 这里我们也利用同样的思想，**从父节点中取出来的与兄弟节点合并的元素，我们可以将它当做一个被删除的节点，重复进行删除时的分析逻辑**，也就是会去递归调用删除后的处理函数



##### 3、关系很模糊的临近兄弟节点 —— 兄弟节点是红色

* 再坚持一下，我们来看看删除的最后一种情况。马上就分析完了

![image-20221112201409280](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1f2831647324194b096a21d6bafece0~tplv-k3u1fbpfcp-zoom-1.image)

* 我们站在B树的角度来看：
    * 第一棵红黑树：`（21）`节点临近的兄弟节点是`（19）`，可是它**在红黑树中却是兄弟节点的子节点**
    * 第二棵也是一样的道理：`（21）`节点临近的兄弟节点是`（18、19）`，可是**在红黑树中却是兄弟节点的子节点，甚至是孙子节点**
* 你回看前两种讨论的情况：
    * 在红黑树中，**待删除节点的兄弟节点都是黑色的**
    * 那在B树中，**与待删除的节点肯定生活在同一层级**，关系很单纯
    * 如果它邻近兄弟的有多的元素，向它借一个，没有就请求它们的父节点帮助

* 可是现在的这种情况：
    * 在红黑树中，**待删除节点的兄弟节点是红色的**
    * 那在B树中，**与待删除的节点肯定不在同一层级**，关系较为复杂
    * 就算B树的临近兄弟有多的元素，也不方便直接借用。没有的话也找不到它们共同的父节点
* 好了，说了老半天，这一段没看懂没关系。你知道一个点就行了：**它们的关系很复杂**
* 既然它们的关系很复杂，能否转换一下，变成我们熟悉的关系呢？

![image-20221112205152610](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02b7e076d464c0ba2406131f0a73bd4~tplv-k3u1fbpfcp-zoom-1.image)

* 先看最终的结果，是不是感觉很熟悉，不熟悉的话，往上翻一下，看看是不是前面**兄弟节点是黑色**的两种情况~~~
* 看完了结果，我来说说其中的思路：
    * 1、将兄弟节点染成黑色、父节点染成红色【保证旋转后红黑树的性质不变】
    * 2、将父节点左旋或右旋，将兄弟节点的子节点变自己的子节点【将侄子变成兄弟。转换成熟悉的关系】
* 这种情况矛盾的地方，其实是：在B树的临近兄弟节点中，没有红黑树的兄弟，导致了较复杂的关系
* 这句话有些绕，用上面的例子来看看：

![image-20221112213112006](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc540551c7744ee5ad408a8133390099~tplv-k3u1fbpfcp-zoom-1.image)

* 再给你看看转换后：

![image-20221112213500466](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0e2d1616c324ec79a9c6162ad5718dc~tplv-k3u1fbpfcp-zoom-1.image)

* 这下你算是知道，为什么会矛盾了吧！！！





### （4）删除的总结

* 再次强调：**一定要想象出一棵红黑树，它等价的B树**
* 因为删除的很多操作都具有对称性，（如：删除二叉搜索树中度为0的节点，它位于左边和右边是完全对称的操作）
* 那么，下面的总结以上面的例子为例：（删除的节点都在右边为例）



#### ① 删除红色节点

![image-20221111183904877](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c18eddeb32cb4262a1509836a9dba67f~tplv-k3u1fbpfcp-zoom-1.image)

* 删除红色节点，并不会对红黑树的性质产生影响，也不会对其等价B树产生影响，所以直接返回即可



#### ② 删除黑色节点

* 下面提到的BST是二叉搜索树
* ❗❗❗一定要想象等价的B树。并且要知道，**在B树中，真正被删除的节点，一定位于最后一层**

##### 1、删除的是BST中“度为2”的节点

![image-20221114113814098](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e791c3eee5784e5db8881a7152666d10~tplv-k3u1fbpfcp-zoom-1.image)

* 这种情况比较特殊。在B树中看起来是删除黑色的节点，但是在红黑树中，真正被删除的是红色节点
* 其实就是上面删除红色节点的情况，那么这一种也不需要特殊处理



##### 2、删除的是BST中度为1的节点

![image-20221111192216962](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff923ac1b3b46479b4f9a5067f683c3~tplv-k3u1fbpfcp-zoom-1.image)



* 这种情况，**该黑色节点有且仅有一个红色子节点**
* 我们需要找到取代它的子节点，将它的子节点染成黑色即可



##### 3、删除的是BST中度为0的节点

* 若BST中度为0，删除之后。在等价B树中会产生下溢现象

* 这里又可以分成三种情况：

###### ⅰ、兄弟是黑色且至少有一个红色的节点

![image-20221112091803449](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2eba06ad6841dabf91f0c0f7bcbb9d~tplv-k3u1fbpfcp-zoom-1.image)

* 如图所示：直接向兄弟借一个节点就行了。不用还的那种哟~
* 最终解决方案：**旋转 + 染色**



###### ⅱ、兄弟节点是黑色且没有一个红色的节点

![image-20221112153839462](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c9d841bb82b434488ef5e51f707298b~tplv-k3u1fbpfcp-zoom-1.image)

* 如图所示：兄弟只有一个黑色的节点，想帮兄弟也借不了啊

* 最终解决方案：**染色（合并）**

* 但是有一种特殊情况，如上图右边所示：
    * 父节点也是黑色的时候。将**父节点向下合并时，父节点也会下溢**

    * 那么需要将向下合并的父节点，**当做是被删除的节点，递归使其恢复性质**



###### ⅲ、兄弟节点是红色

![image-20221112201409280](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08f0d6c3b98445a88386953d1cd44560~tplv-k3u1fbpfcp-zoom-1.image)

* 如图所示：就是我们当时描述的，它们的关系很复杂，我们不熟悉
* 最终解决方案：**将其转换成上面的两种情况：兄弟节点是黑色且....**
* 经过这样的转换，我们就能够统一使用上面的逻辑了

# 红黑树删除的代码实现 —— 篇四

## 二、如何用代码实现红黑树的删除

### （0）实现前的准备

* 分析了这么这么这么久，真是长叹息以掩涕兮了😨🥶😭

* 只不过看看[《红黑树的删除》](https://juejin.cn/post/7179080837726470202) 中对删除的总结，其实也并不是学不会，对吧，如果还有些迷糊，再来看看代码是如何实现的，更迷糊一些吧~

* 在开始实现：`afterRemove()方法`之前，我们先来做两件事情：

    * 1、在`afterRemove()方法中`添加一个参数，稍后再解释为什么

  ![image-20221114182620385](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb36e2614a3143b398e2ae2cda8c075a~tplv-k3u1fbpfcp-zoom-1.image)



* 2、复习二叉搜索树删除的代码逻辑

![image-20221114181923856](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ba38f55e91b412eb49be1ef6986cbec~tplv-k3u1fbpfcp-zoom-1.image)



### （1）几种简单的情况

* 先来看看这几种情况：
    * ①被删除的节点是红色
    * ②BST度为1节点
    * ③真正删除的是根节点
    * ④BST”度为2“的节点
* 看我列了这么多，是不是有些... 别着急，你看看这几种情况的实现，就知道有多简单了

![image-20221114183322790](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a38210ff6cdc41db8494b78ab60833fc~tplv-k3u1fbpfcp-zoom-1.image)

* 这几种情况可以说是最简单的情况了
    * ①：删除的是红色节点，不解释了
    * ②：如果传进来用于取代的子节点是红色，说明该节点肯定是度为 1 的节点嘛，看看删除的代码即可知道
    * ③：取出父节点，若发现父节点是空的。说明只有一个根节点，你把唯一的节点都删除了，直接返回就行了呗（当然，之后可能有其他情况，可能实际不只有一个节点，但是从逻辑上是，也能够满足）
    * ④：？？？都没看到这种情况啊？确实是，代码都不用写，因为真正被删除的节点在B树的最后一层，度又为2，就只能有一种情况了，再看看上面总结~



### （2）下面讨论的情况都是删除的是BST中度为0的节点

* 经过了上面的四种情况，能来到这里说明：
    * 在二叉搜索树中：删除的是度为0的节点
    * 在等价的4阶B树中：删除后会产生下溢现象
    * 在红黑树中：删除的是黑色的节点，且它自己一个子节点都没有
* 通过上面的分析和总结，来到这里我们需要取出兄弟节点来讨论
* 如何取出兄弟节点呢？和之前一样`node.sibling()`吗？
* 其实不然，我们来看看，传入`afterRemove()方法`中节点的大致内存细节

![image-20221116091051015](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0103ec05606a40058d86484012bcafd2~tplv-k3u1fbpfcp-zoom-1.image)

* 可以发现，父节点对自己的引用都已经断掉了，只有自己内部还引用着父节点
* 那我们来看看`node.sibling()`方法，还能拿到真正的兄弟节点吗？

![image-20221116091847002](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c19622866bf4204adf96a710e9f9882~tplv-k3u1fbpfcp-zoom-1.image)

* 看了取兄弟节点的逻辑，是不是发现，根本拿不到兄弟节点了。那该如何拿呢？
* 来到这里删除的肯定是BST中度为0的叶子节点，而删除叶子节点，势必会清除父节点对自己的引用
* 对父节点来说：要么是 `parent.left`会清空，要么是`parent.right`会清空，反过来想想
* 既然**删除的节点在父节点的哪一边，那边就会被清空**。那我们就可以根据哪边是空的，逆推出删除的是左边，还是右边。如果是`parent.left == null`，那么兄弟节点就是：`parent.right`。反之亦然

![image-20221116093437030](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59aae54667124e82a2a508000a594179~tplv-k3u1fbpfcp-zoom-1.image)

* 兄弟节点找到了，直接开始判断吗？
* 回看上面的分析，我们讨论的时候，都是用被删除的节点位于右子树来举例的。其中也提到了，若删除的节点在左边，对于左右操作而言，是完全对称的。并且如何染色也是一致的
* 由此，就可以只实现一边，我们以上面的例子，位于右子树为例。另外一边只需要修改写好后的左右即可

![image-20221116094531510](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f71ef29e2189465c95f750f8c8fbc130~tplv-k3u1fbpfcp-zoom-1.image)



#### ① BST兄弟节点是红色

![image-20221112201409280](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89de2bd6288c461cab6895b037c46f00~tplv-k3u1fbpfcp-zoom-1.image)

* 也就是我们所说的，关系有些复杂的一种情况，我们需要将其转换成熟悉的情况，之后再统一处理

![image-20221116150141290](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58eeb7266ce74ad7acc27bb6efe6310e~tplv-k3u1fbpfcp-zoom-1.image)

* 我们无非是想要将兄弟的子节点（侄子），变成待删除节点的兄弟，所以这里需要通过右旋，就交换了节点
* 但是还需要维护红黑树的性质，所以将其原先的兄弟节点染成【黑色】，父节点染成【红色】
* 最后别忘了要将新的兄弟节点：`sibling 赋值`



#### ② BST兄弟节点是黑色

* 通过上面的操作，成功将兄弟节点是红色的情况转换成了黑色，下面即可统一处理
* 也就是说，来到这里，**兄弟节点肯定是黑色**，那我们就可以根据兄弟是否有红色的子节点来讨论了

![image-20221116150828962](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041b0340f9b948fdba1ac99910a45a53~tplv-k3u1fbpfcp-zoom-1.image)



##### 1、至少有一个红色的子节点

![image-20221112091803449](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f045105afc5d4961ab91880eaad90737~tplv-k3u1fbpfcp-zoom-1.image)

* 这种情况，兄弟节点很富裕，至少可以借一个给我，那就借一个给下溢的兄弟呗
* 通过旋转来借节点的时候，会有三种情况：`左左、左右、左左或左右`，而且旋转完成后，都需要染色来维护性质，那我们可以先处理一些特殊情况：`左右`，之后就可以统一看成`左左`的情况了

![image-20221116151424606](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb550154b074541a43e48021ece1256~tplv-k3u1fbpfcp-zoom-1.image)

* 经过上面的处理后：

![image-20221116151934447](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ab8fb331b4d420e9dbffb887498d0a0~tplv-k3u1fbpfcp-zoom-1.image)

* `LR`的情况变成了`LL`，而有两个红色孩子的情况`左左或右右`，本身就可以看做是`LL`
* 所以能来到下面的分析，肯定都可以看成`LL`的情况

![image-20221116153317504](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f051200cc5f466e9ab43dbdcccb5ff6~tplv-k3u1fbpfcp-zoom-1.image)

* 也就是需要`旋转 + 染色`
    * 因为是LL，所以将父节点右旋即可
    * 旋转后兄弟节点变成了新的中心节点，将中心节点继承旧父节点的颜色，再将中心节点的左右两边都染成黑色即可
* 至于为什么要继承旧父节点的颜色，在上篇文章已经分析过了，可以结合前面的内容，分析分析哟~



##### 2、一个红色的子节点也没有

![image-20221112153839462](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9abd3a9dc24546b5919383de604e2eb7~tplv-k3u1fbpfcp-zoom-1.image)

* 最后一种情况，兄弟也借不了，只能向父节点求助了，也就是`通过染色将父节点和兄弟节点合并`

![image-20221117183049570](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31c73db096d4110b9dd5e8639303906~tplv-k3u1fbpfcp-zoom-1.image)

* 实际上是通过染色解决的下溢，这里就不多解释了
* 还有一点值得注意的是：染色前，需要记录父节点的颜色
    * 如果原先是红色，说明父节点向下合并后，父节点并不会产生下溢现象，不需要额外处理
    * 但是如果原先是黑色，本身就只有一个黑节点了，向下合并后，父节点也将会出现下溢
* 这里的处理逻辑，就是**将父节点当做被删除的节点**，递归执行删除后的逻辑
* 所以，当我们将父节点传入`afterRemove()`方法之后，其中有一处需要调整：

![image-20221117185652319](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d22fb54a19874aaf9b09172301f85be3~tplv-k3u1fbpfcp-zoom-1.image)

* 因为我们仅仅是将父节点当做被删除的节点，所以它执行代码前，**左右子节点的引用肯定不会发生变化**，所以查看是否是左子节点，就得用以前的方式



### （3）对称情况的处理（被删除的节点在左边）

* 在上面，我们已经分析且实现了被删除节点在右边的所有情况。真的谢了✌️✌️
* 一直说它和在左边是对称的。具体有多对称呢？

![image-20221117191313334](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b214f800a194b2ea66fc3131a3b9ab6~tplv-k3u1fbpfcp-zoom-1.image)

* 看我标红色的地方，就是交换左右即可
    * 左边取左，右边就变成取右
    * 左边右旋，右边就左旋
* 当然，有些地方交换了也是一样的效果，就没有交换



### （4）优化`afterRemove()`的参数

* 看完了上面的实现，真的可以说是苦尽甘来啊！！！
* 虽然实现了，我们之前留了一个问题：`afterRemove()方法`中添加了一个参数

![image-20221117192740571](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed54a36e9b6447b7a5e37585d2bb6d33~tplv-k3u1fbpfcp-zoom-1.image)

* 而且这个参数，在整个实现逻辑中，仅在这里用到了
* 还有在AVL树的实现中，其实也没有用到这个参数
* 那我们能否做到，不要这个参数，统一参数呢？
* 当初多传这个参数，是想在红黑树这里方便判断删除的是度为1的节点
* 也就是需要找到用于取代删除节点的节点。其余的地方都不需要改变，仅仅需要处理上面代码的逻辑

* 处理前，我们先看看，在二叉搜索树中，应该如何传入参数，这是一个值得思考的问题

* 先来看看度不是0的情况，改回之前的实现即可【箭头指向的是修改后的代码】

![image-20221117200717357](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7933cf4ae0b04887b6de7a080ef9a447~tplv-k3u1fbpfcp-zoom-1.image)

* 唯一要修改的就是下面度为1的节点

![image-20221117200441200](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6ae577b1829422c9597a7560ac5b794~tplv-k3u1fbpfcp-zoom-1.image)

* 因为`AVL树和红黑树`共用了一个删除模板。所以在考虑传入红黑树的参数时，还得保证`AVL树`删除后的处理是正常的
* 之前在实现`AVL树`的时候，这里是将`被删除节点node`传入了`afterRemove()方法`
* 而现在传入的是`用于取代的child`，那么我们先看看`AVL`树的实现

![image-20221117201420172](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f2945c37a854cf28fca3ff5104d3bfb~tplv-k3u1fbpfcp-zoom-1.image)

* 可以发现，其实并没有影响，这里需要拿到被删除节点的父节点就可以。而我们在传入`child`的时候，本身就已经将被删除节点的父节点赋值给`child.parent`了，逻辑也不需要修改
* 所以并不会产生影响，那红黑树中呢？

* 我们先来修改，再解释：

![image-20221117195748292](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc7bd397fa214ce081e4fcee77934e9c~tplv-k3u1fbpfcp-zoom-1.image)

* 修改这里，应该很好理解，因为传进来的就只有一个参数了
* 就是将上面分析的①②种情况，合并成一致的逻辑了。看看注释的内容



### （5）完整实现`afterRemove(Node<E> node)`

```java
protected void afterRemove(Node<E> node) {
    /*
        ①、被删除的节点是红色的情况
        ②、删除的节点有且仅有一个红色的子节点【也就是在二叉搜索树中删除的度为 1 的节点，找到取代它的子节点】
    */
    if (isRed(node)) {
        /*
            ①：如果被删除的节点是红色的情况，将它染黑也没关系，反正它的内存马上就要释放掉了
            ②：将用于代替被删除节点的子节点染成黑色即可
         */
        black(node);
        return;
    }
    Node<E> parent = node.parent; // 取出被删除节点的父节点

    // ③、如果父节点是空的，说明删除的是根节点
    if (parent == null) return;

    /*
        说明以前删除的是左边
        1、(parent.left == null)是被删除的节点
        2、(node.isLeftChild())是父节点下溢
    */
    boolean isLeft = parent.left == null || node.isLeftChild();
    // 左边为 null 说明右边是兄弟节点，否则是左边
    Node<E> sibling = isLeft ? parent.right : parent.left;

    if (isLeft) { // 被删除的节点在左边，与下面的操作对称
        // 兄弟节点是红色
        if (isRed(sibling)) { // 将其转换为兄弟节点是黑色的两种情况
            rotateLeft(parent); // 左旋，变换兄弟节点
            red(parent); // 父节点染成红色
            black(sibling); // 兄弟节点染成黑色
            sibling = parent.right; // 兄弟节点变了，改变引用
        }
        // 能来到这里，兄弟节点肯定是黑色的了
        if (isRed(sibling.right) || isRed(sibling.left)) { // 兄弟至少有一个红色的子节点
            if (isRed(sibling.left)) { // RL的情况，将其转换为RR，与下面统一处理
                rotateRight(sibling); // 兄弟节点右旋
                sibling = parent.right; // 兄弟节点变化了
            }
            // 能来到这里，说明都可以看成是RR的情况了
            rotateLeft(parent); // 将父节点左旋
            /*
                1、兄弟节点变成了新的父节点（新的中心节点）
                2、将新父节点的颜色继承旧父节点的颜色
                3、将新父节点的左右子节点都染成黑色
            */
            color(sibling, colorOf(parent));
            black(sibling.left);
            black(sibling.right);
        } else { // 兄弟一个红色的子节点都没有
            boolean isBlack = isBlack(parent); // 记录父节点原先的颜色
            // 将父节点染成黑色，兄弟节点染成红色
            black(parent);
            red(sibling);
            if (isBlack) { // 如果父节点原先就是黑色的
                afterRemove(parent); // 说明向下合并后，它也会下溢，将它当做被删除的节点
            }
        }
    } else { // 被删除的节点在右边，与上面的操作对称
        // 兄弟节点是红色
        if (isRed(sibling)) { // 将其转换为兄弟节点是黑色的两种情况
            rotateRight(parent); // 右旋，变换兄弟节点
            red(parent); // 父节点染成红色
            black(sibling); // 兄弟节点染成黑色
            sibling = parent.left; // 兄弟节点变了，改变引用
        }
        // 能来到这里，兄弟节点肯定是黑色的了
        if (isRed(sibling.left) || isRed(sibling.right)) { // 兄弟至少有一个红色的子节点
            if (isRed(sibling.right)) { // LR的情况，将其转换为LL，与下面统一处理
                rotateLeft(sibling); // 兄弟节点左旋
                sibling = parent.left; // 兄弟节点变化了
            }
            // 能来到这里，说明都可以看成是LL的情况了
            rotateRight(parent); // 将父节点右旋
            /*
                1、兄弟节点变成了新的父节点（新的中心节点）
                2、将新父节点的颜色继承旧父节点的颜色
                3、将新父节点的左右子节点都染成黑色
            */
            color(sibling, colorOf(parent));
            black(sibling.left);
            black(sibling.right);
        } else { // 兄弟一个红色的子节点都没有
            boolean isBlack = isBlack(parent); // 记录父节点原先的颜色
            // 将父节点染成黑色，兄弟节点染成红色
            black(parent);
            red(sibling);
            if (isBlack) { // 如果父节点原先就是黑色的
                afterRemove(parent); // 说明向下合并后，它也会下溢，将它当做被删除的节点
            }
        }
    }
}
```

* 至此，终于将红黑树的删除分析完成了
* 如果你真的耐心的看到了这里，那和我一起击个掌怎么样~ 🤚🤚🤚






